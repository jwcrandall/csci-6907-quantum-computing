\documentclass[main.tex]{subfiles}
\begin{document}

\href{https://www2.seas.gwu.edu/~simhaweb/quantum/modules/module8/module8.html}{Module 8: Quantum circuits - reversible construction}

\subsection{What is reversible construction?}

    Let's first describe what is meant by this term at a high-level, and then ask why it's useful. Steps in reversible construction: The starting point is: a computational problem we'd like to solve. Step 1: Solve the problem classically using a classical (Boolean) circuit shown in Figure \ref{fig:01reversible}.
    
    \begin{figure}
        \centering
        \includegraphics[width=5in]{notes/figs/n10/01reversible1.png}
        \caption{Classical (Boolean) Circuit}
        \label{fig:01reversible}
    \end{figure}
    
    Step 2: Replace the classical gates with classical reversible versions shown in Figure \ref{fig:02reversible2}.
    
    \begin{figure}
        \centering
        \includegraphics[width=5in]{notes/figs/n10/02reversible2.png}
        \caption{Classical reversible versions}
        \label{fig:02reversible2}
    \end{figure}
    
    Here, each classical gate $C_{i}$ is replaced by a reversible equivalent $R_{i}$. The reversible ones are typically larger (more inputs and outputs). Step 3: Substitute quantum (reversible) equivalents of the reversible classical gates, and use qubits shown in Figure \ref{fig:03reversible3}.
    
    \begin{figure}
        \centering
        \includegraphics[width=5in]{notes/figs/n10/03reversible3.png}
        \caption{Quantum (reversible) equivalents}
        \label{fig:03reversible3}
    \end{figure}
    
    Quantum gates are already reversible (unitaries are invertible). Step 4: Optionally, optimize the quantum circuit. Terminology: the extra "work space qubits" are often called ancillae qubits (Singular: ancilla). Let's ask: why construct a quantum circuit of the same size if a classical circuit solves a problem? The answer: we can feed as input a superposition of all standard-basis vectors:
    
    $$
    \left|\psi_{\text {input }}\right\rangle=\frac{1}{\sqrt{N}} \sum_{i}|i\rangle=\frac{1}{\sqrt{N}}(|00 \ldots 0\rangle+\ldots+|11 \ldots 1\rangle)
    $$
    
    The hope is that the quantum circuit can act on all in parallel. However: we need to measure at the end. Measurement will result in only one output. And this too is random. Thus, one needs more than the reversible construction: Additional circuitry is needed to arrange for some desired outputs to occur with higher probability. Interference! Why consider this approach? This is one of three high-level approaches to quantum circuit: 1. Crafting circuits by hand. 2. Algorithmically converting a giant unitary into circuits with as few gates as possible. 3. Reversible construction. So far, only the first approach has been successful. There is on-going work in the second. The third, the reversible approach, at least provides a starting point that one can further optimize. Also, even hand-crafted quantum circuits make use of building blocks: For example: an adder. These can be implemented via classical circuits and then optimized. The reversible approach also proves that a quantum circuit can, with low overhead, implement a classical circuit.
    
\subsection{Binary-variable notation}

    It will be convenient to introduce some notational conventions for binary variables, to be used in three situations. First: we use them to describe Boolean gates: Example: the classical NOT gate shown in Figure \ref{fig:04classical-not}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/04classical-not.png}
        \caption{NOT gate}
        \label{fig:04classical-not}
    \end{figure}
    
    We write this as
    
    $$
    \operatorname{NOT}(x)=x^{\prime}
    $$
    
    Next, the classical AND gate shown in Figure \ref{fig:05classical-and}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/05classical-and.png}
        \caption{And gate}
        \label{fig:05classical-and}
    \end{figure}
    
    Which we write as any of
    
    $$
    \operatorname{AND}\left(x_{1}, x_{2}\right)=x_{1} \wedge x_{2}=x_{1} x_{2}
    $$
    
    Here, variables like $x_{1}, x_{2}$ are binary variables. Each $x_{i} \in\{0,1\}$. Typically, lower case letters are used. The classical OR gate is shown in Figure \ref{fig:06classical-or}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/06classical-or.png}
        \caption{OR gate}
        \label{fig:06classical-or}
    \end{figure}
    
    written symbolically as
    
    $$
    \operatorname{OR}\left(x_{1}, x_{2}\right)=x_{1} \vee x_{2}=x_{1}+x_{2}
    $$
    
    And, an important one for us: the XOR gate shown in Figure \ref{fig:07classical-xor}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/07classical-xor.png}
        \caption{OR gate}
        \label{fig:07classical-xor}
    \end{figure}
    
    Note the XOR symbol: $x_{1} \oplus x_{2}$. A useful property that XOR shares with AND, OR:
    
    $$
    x_{1} \oplus\left(x_{2} \oplus x_{3}\right)=\left(x_{1} \oplus x_{2}\right) \oplus x_{3}
    $$
    
    So that we can write (unambiguously): $x_{1} \oplus x_{2} \oplus x_{3}$. Also: $x \oplus x=0$. The second use for binary variables is in compactly describing quantum gates: For example, here is a description of the quantum $X$ gate:
    
    $$
    X|a\rangle=\left|a^{\prime}\right\rangle
    $$
    
    Here, $a$ is a binary variable, used only for notational convenience. Thus, when $a=0$
    
    $$
    X|a\rangle=X|0\rangle=\left|0^{\prime}\right\rangle=|1\rangle
    $$
    
    Similarly, when $a=1$
    
    $$
    X|a\rangle=X|1\rangle=\left|1^{\prime}\right\rangle=|0\rangle
    $$
    
    There is no unique way to write such binary-variable descriptions: For example, we could just as easily describe $X$ as:
    
    $$
    X|a\rangle=|1 \oplus a\rangle
    $$
    
    A slightly harder-to-read example:
    
    $$
    H|a\rangle=\frac{1}{\sqrt{2}}\left(|0\rangle+(-1)^{a}|1\rangle\right)
    $$
    
    When $a=0$ :
    
    $$
    H|0\rangle=\frac{1}{\sqrt{2}}\left(|0\rangle+(-1)^{0}|1\rangle\right)=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)=|+\rangle
    $$
    
    When $a=1$ :
    
    $$
    H|1\rangle=\frac{1}{\sqrt{2}}\left(|0\rangle+(-1)^{1}|1\rangle\right)=\frac{1}{\sqrt{2}}(|0\rangle-|1\rangle)=|-\rangle
    $$
    
    Note: The notation is used to describe what happens with standard basis vectors: It is these vectors that can be described with binary variables. It may not work with non-binary variables, for example
    
    $$
    X|+\rangle=X \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)=\frac{1}{\sqrt{2}}(X|0\rangle+X|1\rangle)=|+\rangle
    $$
    
    So, substituting $a=+\operatorname{in} X|a\rangle=\left|a^{\prime}\right\rangle$ does not work. Quantum gates can of course operate on other non-standard-basis inputs. One would need to infer properties for general vectors, such as:
    
    $$
    X(\alpha|0\rangle+\beta|1\rangle)=\beta|0\rangle+\alpha|1\rangle
    $$
    
    The Boolean description is only a notational convenience. It does not mean we are mixing classical and quantum circuits. Let's now describe $C_{N O T}$ (on standard-basis vectors) with this approach:
    
    $$
    C_{N O T}|x, y\rangle=|x, x \oplus y\rangle
    $$
    
    These are the four input cases:
    
    $$
    \begin{array}{|c|c|c|}
    \hline|x\rangle & |y\rangle & |x, x \oplus y\rangle \\
    \hline|0\rangle & |0\rangle & |0,0 \oplus 0\rangle=|00\rangle \\
    |0\rangle & |1\rangle & |0,0 \oplus 1\rangle=|01\rangle \\
    |1\rangle & |0\rangle & |1,1 \oplus 0\rangle=|11\rangle \\
    |1\rangle & |1\rangle & |1,1 \oplus 1\rangle=|10\rangle \\
    \hline
    \end{array}
    $$
    
    Recall the Toffoli $\left(C C_{\text {Nот }}\right)$ gate shown in Figure \ref{fig:08toffoli}.
    
    \begin{figure}
        \centering
        \includegraphics[width=3in]{notes/figs/n10/08toffoli.png}
        \caption{Toffoli}
        \label{fig:08toffoli}
    \end{figure}
    
    The matrix is:
    
    $$
    \left[\begin{array}{llllllll}
    1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & \mathbf{1} \\
    0 & 0 & 0 & 0 & 0 & 0 & \mathbf{1} & 0
    \end{array}\right]
    $$
    
    Algebraically, we describe this as
    
    $$
    \operatorname{TOF}|x, y, z\rangle=|x, y, x y \oplus z\rangle
    $$
    
    Thus, only when $x$ and $y$ are both 1 does $z$ get flipped. Let's use this Boolean-algebraic approach to show that the Toffoli gate is its own inverse:
    
    $$
    \begin{aligned}
    \operatorname{TOF}(\operatorname{TOF}|x, y, z\rangle) &=\operatorname{TOF}(|x, y, x y \oplus z\rangle) \\
    &=|x, y, x y \oplus(x y \oplus z)\rangle \\
    &=|x, y,(x y \oplus x y) \oplus z\rangle \\
    &=|x, y, 0 \oplus z\rangle \\
    &=|x, y, z\rangle
    \end{aligned}
    $$
    
    Similarly, the Fredkin gate can be written as:
    
    $$
    F|x, y, z\rangle=\left|x, x^{\prime} y+x z, x^{\prime} z+x y\right\rangle
    $$
    
    The form is not as simple as the Toffoli gate. The third use of binary variables: naming bits in standard-basis vectors. Consider the 4-qubit vector $|1101\rangle$. We use the notation $\left|b_{3} b_{2} b_{1} b_{0}\right\rangle$ to describe any 4-qubit standard-basis vector. Here, each $b_{i} \in\{0,1\}$ is a binary variable. Thus, with $b_{3}=1, b_{2}=1, b_{1}=0, b_{0}=1$, we get the standard basis vector $|1101\rangle$. In general, an n-qubit standard-basis vector can be written as $\left|b_{n-1} b_{n-2} \ldots b_{1} b_{0}\right\rangle$. Terminology: The leftmost bit is called the most significant bit. And the rightmost, the least significant bit. To see why, consider how the decimal equivalent is built out of the bits:
    
    $$
    k=b_{n-1} 2^{n-1}+b_{n-2} 2^{n-2}+\ldots b_{1} 2^{1}+b_{0} 2^{0}
    $$
    
    For example
    
    $$
    \begin{aligned}
    |1101\rangle &=\left|b_{3} 2^{3}+b_{2} 2^{2}+b_{1} 2^{1}+b_{0} 2^{0}\right\rangle \\
    &=\left|2^{3}+2^{2}+1\right\rangle \\
    &=|13\rangle
    \end{aligned}
    $$
    
    The drawing convention is to place the qubit equivalent to the most significant bit on top shown in Figure \ref{09binary}.
    
    \begin{figure}
        \centering
        \includegraphics[width=3in]{notes/figs/n10/09binary.png}
        \caption{4-qubit standard basis vector}
        \label{fig:09binary}
    \end{figure}
    
    Bitwise or binary-string operators: It will be useful to extend some operators to binary strings. Let
    
    $$
    \begin{aligned}
    &b=b_{n-1} b_{n-2} \ldots b_{1} b_{0} \\
    &c=c_{n-1} c_{n-2} \ldots c_{1} c_{0}
    \end{aligned}
    $$
    
    represent two binary strings. Then, define:
    
    $$
    \begin{aligned}
    b \wedge c &=b_{n-1} \wedge c_{n-1} \ldots b_{0} \wedge c_{0} \\
    b \oplus c &=b_{n-1} \oplus c_{n-1} \ldots b_{0} \oplus c_{0}
    \end{aligned}
    $$
    
    For example, suppose
    
    $$
    \begin{aligned}
    &b=1011 \\
    &c=1001
    \end{aligned}
    $$
    
    Then
    
    $$
    \begin{aligned}
    &b \wedge c=(1 \wedge 1)(0 \wedge 0)(1 \wedge 0)(1 \wedge 1)=1001 \\
    &b \oplus c=(1 \oplus 1)(0 \oplus 0)(1 \oplus 0)(1 \oplus 1)=0010
    \end{aligned}
    $$
    
    And, it's also convenient to extend the real-vector dot product to binary strings:
    
    $$
    b \cdot c=b_{n-1} c_{n-1}+\ldots+b_{0} c_{0}=\text { Number of common } 1 \text { 's }
    $$
    
    Example:
    
    $$
    1011 \cdot 1001=(1 \cdot 1)+(0 \cdot 0)+(1 \cdot 0)+(1 \cdot 1)=2
    $$
    
    There's a useful variation of the dot product:
    
    $$
    (b \cdot c)_{2}=(b \cdot c) \bmod 2
    $$
    
    Example:
    
    $$
    (1011 \cdot 1001)_{2}=((1 \cdot 1)+(0 \cdot 0)+(1 \cdot 0)+(1 \cdot 1))_{2}=2 \bmod 2=0
    $$
    
    The binary-variable notation enables creating useful algebraic identities, as in this example: Recall how we created the n-qubit all-vector equal superposition from the all-zero input vector:
    
    $$
    (H \otimes H \otimes \ldots \otimes H)|0\rangle|0\rangle \ldots|0\rangle=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1}|k\rangle
    $$
    
    where $N=2^{n}$ and $k$ is decimal. For example,
    
    $$
    \begin{aligned}
    (H \otimes H)|0\rangle|0\rangle &=\frac{1}{\sqrt{4}} \sum_{k=0}^{3}|k\rangle \\
    &=\frac{1}{\sqrt{4}}(|0\rangle+|1\rangle+|2\rangle+|3\rangle) \\
    &=\frac{1}{2}(|00\rangle+|01\rangle+|10\rangle+|11\rangle)
    \end{aligned}
    $$
    
    Sometimes, this is called the Walsh-Hadamard transform:
    
    $$
    W=H \otimes H \otimes \ldots \otimes H
    $$
    
    and so
    
    $$
    W|00 \ldots 0\rangle=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1}|k\rangle
    $$
    
    Although $W$ was applied above to $|00 \ldots 0\rangle$ we will want to see what it does to any standard-basis vector. Let $k$ and $m$ be two decimal numbers with binary representation
    
    $$
    \begin{aligned}
    k &=b_{n-1} \ldots b_{0} \triangleq b \\
    m &=c_{n-1} \ldots c_{0} \triangleq c
    \end{aligned}
    $$
    
    where we've defined variables $b, c$ to represent the binary strings $b_{n-1}+\ldots b_{0}$ and $c_{n-1}+\ldots c_{0}$. We'll also use the terms
    
    $$
    \begin{array}{ll}
    k=\operatorname{decimal}(b) & \text { Convert binary string } b \text { to decimal number } k \\
    b=\operatorname{binary}(k) & \text { Binary string } b \text { from decimal number } k
    \end{array}
    $$
    
    Recall that the action of $H$ can be written as
    
    $$
    H|x\rangle=\frac{1}{\sqrt{2}}\left(|0\rangle+(-1)^{x}|1\rangle\right)
    $$
    
    where, on the left, $|x\rangle=|0\rangle$ when $x=0$, and $|x\rangle=|1\rangle$ when $x=1$. Then, noting that the right side basis vectors can be written the same way, with bit strings,
    
    $$
    \begin{aligned}
    H|x\rangle &=\frac{1}{\sqrt{2}}\left((-1)^{0}|0\rangle+(-1)^{x \cdot 1}|1\rangle\right) \\
    &=\frac{1}{\sqrt{2}}\left((-1)^{x \cdot 0}|0\rangle+(-1)^{x \cdot 1}|1\rangle\right) \\
    &=\frac{1}{\sqrt{2}} \sum_{y=0}^{1}(-1)^{x \cdot y}|y\rangle
    \end{aligned}
    $$
    
    Here, we introduced an additional binary variable $y$ for the sum. Then,
    
    $$
    \begin{aligned}
    &W|m\rangle=W\left|c_{n-1}\right\rangle\left|c_{n-2}\right\rangle \ldots\left|c_{1}\right\rangle\left|c_{0}\right\rangle\\
    &=W\left(\left|c_{n-1}\right\rangle \otimes \ldots \otimes\left|c_{0}\right\rangle\right)\\
    &=(H \otimes \ldots \otimes H)\left(\left|c_{n-1}\right\rangle \otimes \ldots \otimes\left|c_{0}\right\rangle\right)\\
    &=H\left|c_{n-1}\right\rangle \otimes \ldots \otimes H\left|c_{0}\right\rangle\\
    &=\frac{1}{\sqrt{2}}\left(|0\rangle+(-1)^{c_{n-1}}|1\rangle\right) \otimes \ldots \otimes \frac{1}{\sqrt{2}}\left(|0\rangle+(-1)^{c_{0}}|1\rangle\right)\\
    &=\frac{1}{\sqrt{2}}\left(\sum_{b_{n-1}=0}^{1}(-1)^{c_{n-1} b_{n-1}}\left|b_{n-1}\right\rangle\right) \otimes \ldots \otimes \frac{1}{\sqrt{2}}\left(\sum_{b_{0}=0}^{1}(-1)^{c_{0} b_{0}}\left|b_{0}\right\rangle\right)\\
    &=\frac{1}{\sqrt{2^{n}}} \sum_{b_{n-1}, \ldots, b_{0}}(-1)^{c_{n-1} \cdot b_{n-1}} \ldots(-1)^{c_{0} \cdot b_{0}}\left(\left|b_{n-1}\right\rangle \otimes \ldots \otimes\left|b_{0}\right\rangle\right)\\
    &=\frac{1}{\sqrt{N}} \sum_{b_{n-1}, \ldots, b_{0}}(-1)^{c \cdot b}\left(\left|b_{n-1} \ldots b_{0}\right\rangle\right)\\
    &=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1}(-1)^{c \cdot b}|k\rangle
    \end{aligned}
    $$
    
    Note: the $b_{i}$ 's are introduced as binary variables, one for each $i$ and are then "collected" into the binary string $b_{n-1} \ldots b_{0}$, which then got converted to its decimal form $k$. This is useful enough to make a proposition out of it: Proposition 8.1: The action of the Walsh-Hadamard transform on an arbitrary n-qubit basis vector $|m\rangle$ is
   
    $$
    W|m\rangle=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1}(-1)^{c \cdot b}|k\rangle
    $$
    
    where $c=\operatorname{binary}(m), b=\operatorname{binary}(k)$ and $N=2^{n}$. Application: Many algorithms start with the full-superposition. This result enables their analysis in later stages of an algorithm's circuit.
    

\subsection{Irreversible classical gates and their reversible replacements}

    In this section, we'll focus on classical gates. In places, we'll use the conventions and tools of quantum gates for classical gates (which can, at first, be a little confusing). Let's use the simple XOR gate as an example: Consider this example output in Figure \ref{fig:10xor-gate1}.
    
    \begin{figure}
        \centering
        \includegraphics[width=3in]{notes/figs/n10/10xor-gate1.png}
        \caption{XOR Gate}
        \label{fig:10xor-gate1}
    \end{figure}
    
    Looking at the output (0, in this case), one cannot infer the inputs shown in Figure \ref{fig:11xor-gate1b}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/11xor-gate1b.png}
        \caption{XOR Output}
        \label{fig:11xor-gate1b}
    \end{figure}
    
    Inferring the input is, of course, possible with the NOT gate shown in Figure \ref{fig:12xor-gate2}.
    
    \begin{figure}
        \centering
        \includegraphics[width=5in]{notes/figs/n10/12xor-gate2.png}
        \caption{NOT Gate}
        \label{fig:12xor-gate2}
    \end{figure}
    
    We say that NOT is reversible while the basic XOR-gate is not reversible. That said, a tiny tweak makes it reversible shown in Figure \ref{fig:13xor-gate3}.
    
    \begin{figure}
        \centering
        \includegraphics[width=5in]{notes/figs/n10/13xor-gate3.png}
        \caption{XOR reversible}
        \label{fig:13xor-gate3}
    \end{figure}
    
    Here, we have included one of the inputs as an output. Then, knowing the full output (both bits) lets us uniquely infer the inputs. Let's examine the truth-table to clarify shown in Figure \ref{fig:14xor-gate4}.
    
    \begin{figure}
        \centering
        \includegraphics[width=5in]{notes/figs/n10/14xor-gate4.png}
        \caption{XOR reversible truth table}
        \label{fig:14xor-gate4}
    \end{figure}
    
    Each pair of outputs is unique. Thus, the outputs uniquely determine the inputs. We could call this version the XOR-with-x gate. We would find that XOR-with-y is also reversible. We'll now take this idea a step further: We know that all quantum gates are reversible as shown in Figure \ref{fig:15quantum-gate}.
    
    \begin{figure}
        \centering
        \includegraphics[width=5in]{notes/figs/n10/15quantum-gate.png}
        \caption{reversible quantum gates}
        \label{fig:15quantum-gate}
    \end{figure}
    
    Any quantum gate is a unitary operation $U$. And $U$ has an inverse $U^{-1}=U^{\dagger}$. Thus, applying $U^{\dagger}$ recovers the input. We now ask: can we use the representation (vectors, matrices) for quantum gates for reversible classical gates? Let's try this with the 2-input XOR gate: The four possible inputs are $00,01,10,11$. Suppose we use the same vectors to represent these that we used for $|00\rangle,|01\rangle,|10\rangle,|11\rangle$. That is:
    
    $$
    \text { input } 00=\left[\begin{array}{l}
    1 \\
    0 \\
    0 \\
    0
    \end{array}\right]=|00\rangle \quad \text { input } 01=\left[\begin{array}{l}
    0 \\
    1 \\
    0 \\
    0
    \end{array}\right]=|01\rangle \quad \text { input } 10=\left[\begin{array}{l}
    0 \\
    0 \\
    1 \\
    0
    \end{array}\right]=|10\rangle \quad \text { input } 11=\left[\begin{array}{l}
    0 \\
    0 \\
    0 \\
    1
    \end{array}\right]=|11\rangle
    $$
    
    Note: with classical gates, these are the only inputs and outputs. There are no linear combinations or complex scalars. Next, let's represent the XOR gate by the matrix
    
    $$
    \mathrm{XOR}=\left[\begin{array}{llll}
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 1 \\
    0 & 0 & 1 & 0
    \end{array}\right]
    $$
    
    Then
    
    $$
    \begin{array}{lll}
    \text { XOR }|00\rangle=|00\rangle & & \text { Outputs } 0,0 \\
    \text { XOR }|01\rangle=|01\rangle & & \text { Outputs } 0,1 \\
    \text { XOR }|10\rangle=|11\rangle & & \text { Outputs } 1,1 \\
    \text { XOR }|11\rangle=|10\rangle & & \text { Outputs } 1,0
    \end{array}
    $$
    
    $$
    \begin{aligned}
    \text { XOR } &=|00\rangle\langle 00|+| 01\rangle\langle 01|+| 10\rangle\langle 11|+| 11\rangle\langle 10| & \text { Binary } \\
    &=|0\rangle\langle 0|+| 1\rangle\langle 1|+| 2\rangle\langle 3|+| 3\rangle\langle 2| & \text { Decimal }
    \end{aligned}
    $$
    
    How did we derive the matrix? We can examine the input-to-output list above and write out the Dirac form: Alternatively, recall, we can use the sandwich approach and compute each entry $\langle i|X O R| j\rangle$ for $i, j \in\{0,1,2,3\}$ (decimal). A further insight: permutation matrices. A permutation matrix has the property: there is only a single 1 in every row and every column, with all other entries being 0. Such a matrix permutes the elements of a vector, as in
    
    $$
    \left[\begin{array}{llll}
    1 & 0 & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 1
    \end{array}\right]\left[\begin{array}{l}
    a \\
    b \\
    c \\
    d
    \end{array}\right]=\left[\begin{array}{l}
    a \\
    c \\
    b \\
    d
    \end{array}\right]
    $$
    
    Why is this true? Think of the identity matrix has having rows that successively "act" on vector elements: $\triangleright$ Row $k$ of $I$ "picks off" element $v_{k}$ in vector $\mathbf{v}$. A permutation matrix is merely a permutation of the rows of $I$. Thus, if we were to use permutation matrices as classical gates, they would perforce be reversible. For example: we've seen how to do this for XOR. Unfortunately, a 2-input solution does not exist for AND and OR. Using Toffoli as a reversible classical gate: Let's borrow the Toffoli matrix from its quantum equivalent:
    
    $$
    \text { TOF }=\left[\begin{array}{llllllll}
    1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & \mathbf{1} \\
    0 & 0 & 0 & 0 & 0 & 0 & \mathbf{1} & 0
    \end{array}\right]
    $$
    
    We already know that its effect on standard-basis vectors can be described as:
    
    $$
    \operatorname{TOF}|x, y, z\rangle=|x, y, x y \oplus z\rangle
    $$
    
    Now observe that
    
    $$
    \operatorname{TOF}|x, y, 0\rangle=|x, y, x y \oplus 0\rangle=|x, y, x \wedge y\rangle
    $$
    
    Thus, we have a gate that can be used to compute $x \wedge y$ shown in Figure \ref{fig:16toffoli2}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/16toffoli2.png}
        \caption{TOF And}
        \label{fig:16toffoli2}
    \end{figure}
    
    Next, a NOT-gate can be constructed as shown in Figure \ref{fig:17toffoli3}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/17toffoli3.png}
        \caption{TOF Not}
        \label{fig:17toffoli3}
    \end{figure}
    
    That is,
    
    $$
    \operatorname{TOF}|1,1, z\rangle=|x=1, y=1,(1 \wedge 1) \oplus z\rangle=\left|1,1, z^{\prime}\right\rangle
    $$
    
    Finally, an OR gate is more complicated: First,
    
    $$
    x \vee y=\left(x^{\prime} \wedge y^{\prime}\right)^{\prime}
    $$
    
    Which we can also write as
    
    $$
    \operatorname{OR}(x, y)=\operatorname{NOT}(\operatorname{AND}(\operatorname{NOT}(x), \operatorname{NOT}(y)))
    $$
    
    Thus, working inwards
    
    $$
    \begin{aligned}
    \operatorname{OR}(x, y) &=\operatorname{TOF}(1,1, \operatorname{AND}(\operatorname{NOT}(x), \operatorname{NOT}(y))) \\
    &=\operatorname{TOF}(1,1, \operatorname{TOF}(\operatorname{NOT}(x), \operatorname{NOT}(y), 0)) \\
    &=\operatorname{TOF}(1,1, \operatorname{TOF}(\operatorname{TOF}(1,1, x), \operatorname{TOF}(1,1, y), 0))
    \end{aligned}
    $$
    
    This is easier to see in a diagram shown in Figure \ref{fig:18toffoli4}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/18toffoli4.png}
        \caption{TOF OR}
        \label{fig:18toffoli4}
    \end{figure}
    
    Thus, the Toffoli gate is universal for classical circuits: Any classical circuit can be built solely out of AND and NOT gates. Each such gate can be replaced by the above Toffoli equivalents, along with extra bits. Note, with NOT gates, one can make the Toffoli-OR circuit a bit more efficient shown in Figure \ref{fig:19toffoli5}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/19toffoli5.png}
        \caption{Efficient Toffoli-OR}
        \label{fig:19toffoli5}
    \end{figure}
    
    What about these extra bits? The spare or extra bits are an additional cost in such an implementation. In a classical circuit, they can just be discarded. However, this discarding cannot easily be done in a quantum circuit because the extra bits may get entangled with the output bits. An alternative: the Fredkin or Controlled-NOT gate shown in Figure \ref{fig:20fredkin}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/20fredkin.png}
        \caption{Fredkin}
        \label{fig:20fredkin}
    \end{figure}
    
    We can write the Fredkin algebraically on standard-basis vectors as:
    
    $$
    F|x, y, z\rangle=\left|x, x^{\prime} y+x z, x^{\prime} z+x y\right\rangle
    $$
    
    where $x, y, z$ are all binary variables. Observe that
    
    $$
    F|x, 0,1\rangle=\left|x, x, x^{\prime}\right\rangle
    $$
    
    Thus, the third output can be used as $\operatorname{NOT}(x)$ shown in Figure \ref{fig:21fredkin2}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/21fredkin2.png}
        \caption{$\operatorname{NOT}(x)$}
        \label{fig:21fredkin2}
    \end{figure}
    
    The Fredkin gate is also universal: it can implement the NOT, AND, OR classical gates. Recall that the Fredkin is a controlled-SWAP and thus can also be written as:
    
    $$
    F|x, y, z\rangle=\left(I \otimes \operatorname{SWAP}^{x}\right)|x, y, z\rangle=|x\rangle \otimes \operatorname{SWAP}^{x}|y, z\rangle
    $$
    
    where $\operatorname{SWAP}^{0}=I \otimes I$.
    
    The meaning of the classical versions of Toffoli, Fredkin and other such gates: Let's review what we know about qubits and unitary operations: Qubits are hardware devices that can hold a quantum state. A quantum state is represented mathematically by a vector. Qubits are modified by other hardware devices (lasers, magnetic fields, for example). These modifications are mathematically represented by unitary matrices. Now let's review classical circuitry: Bits are stored in flip-flops or 1-bit registers. Each bit is mathematically represented by a binary variable taking a value 0 or 1 . Bits are modified using classical gates like AND, OR, NOT. These are hardware devices that take bits as input and deliver the desired output bits. Classical gates are modeled by Boolean functions. So, what does it mean to represent classical gates with unitary matrices? The idea is to simulate a classical circuit using a quantum circuit. The input to the simulating quantum circuit is a standard-basis vector. Then, if we use the appropriate quantum gates (with Toffoli gates, for example), one can simulate AND and NOT. Then, the output vector can be interpreted as representing a classical-circuit output. Note: the output of the simulating quantum circuit will always be a standard-basis vector because: The input is always a single standard-basis vector. Each unitary is a permutation matrix by design: All the quantum versions of classical gates are permutations. Products and tensors of permutations are permutations. (See section below.) The output is therefore always a standard-basis vector. After designing for standard-basis vectors as input/output, we can of course subject a quantum circuit to superpositions, if that suits our purpose. Cloning with standard basis vectors: While in general cloning is not possible, we can use $C_{NOT}$ gates to clone standard-basis vectors, for example view Figure \ref{fig:22cloning}.
    
    \begin{figure}
        \centering
        \includegraphics[width=4in]{notes/figs/n10/22cloning.png}
        \caption{$C_{NOT}$ gates to clone standard-basis vectors}
        \label{fig:22cloning}
    \end{figure}

\subsection{An example: half-adder}

\subsection{Permutations and classical-to-quantum conversion}

\subsection{Summary of two approaches: classical to quantum}

\subsection{Un-computing}

\subsection{Efficient reversible classical circuits}

\end{document}